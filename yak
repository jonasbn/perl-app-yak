#!/usr/bin/env perl

use strict;
use warnings;
use v5.10; # say
           # stacked file tests, REF: https://perldoc.perl.org/functions/-X

use utf8;
use JSON; # from_json
use YAML::Tiny;
use Crypt::Digest::SHA256 qw(sha256_file_hex); # Provided by CryptX
use Env qw($HOME);
use Data::Dumper;
use File::Find; # find
use List::MoreUtils qw(any);
use Term::ANSIColor qw(:constants);
use Text::Gitignore qw(match_gitignore build_gitignore_matcher);
use English; # $PROGRAM_NAME
use Getopt::Long; # GetOptions
use Cwd; # getcwd
use File::Slurper qw(read_lines);
use Data::Stack;

binmode STDOUT, ":utf8";
binmode STDERR, ":utf8";

use constant FALSE   => 0;
use constant TRUE    => 1;
use constant SUCCESS => 0;
use constant FAILURE => 1;

our $VERSION = '1.0.0';

my $default_checksums_src = "$HOME/.config/yak/checksums.json";
my $default_config_file   = "$HOME/.config/yak/config.yml";

my $success_emoji;
my $failure_emoji;
my $skip_emoji;
my $ignore_emoji;

my $debug_flag       = FALSE;
my $nodebug_flag     = FALSE;
my $verbosity_flag   = FALSE;
my $silent_flag      = FALSE;
my $noconfig_flag    = FALSE;
my $nochecksums_flag = FALSE;
my $about_flag       = FALSE;
my $help_flag        = FALSE;
my $nocolor_flag     = FALSE;
my $color_flag       = FALSE;
my $noemoji_flag     = FALSE;
my $emoji_flag       = FALSE;
my $rv               = SUCCESS;
my $checksums_src    = '';
my $config_src       = '';

GetOptions ('debug'       => \$debug_flag,
            'nodebug'     => \$nodebug_flag,
            'verbose'     => \$verbosity_flag,
            'noconfig'    => \$noconfig_flag,
            'config=s'    => \$config_src,
            'silent'      => \$silent_flag,
            'nochecksums' => \$nochecksums_flag,
            'checksums=s' => \$checksums_src,
            'nocolor'     => \$nocolor_flag,
            'color'       => \$color_flag,
            'noemoji'     => \$noemoji_flag,
            'emoji'       => \$emoji_flag,
            'about'       => \$about_flag,
            'help'        => \$help_flag,
) or die "Error in command line arguments\n";

# Reading the config
my ($config, $config_file) = _read_config($noconfig_flag, $config_src);

my $verbose = _enable_verbose($verbosity_flag, $silent_flag, $config);
my $debug = _enable_debug($debug_flag, $nodebug_flag, $config);
my $color = _enable_color($color_flag, $nocolor_flag, $config);
my $emoji = _enable_emoji($emoji_flag, $noemoji_flag, $config);

if ($emoji) {
    $success_emoji = _set_emoji('success_emoji', $config) || '👍🏻';
    $failure_emoji = _set_emoji('failure_emoji', $config) || '❗️';;
    $skip_emoji    = _set_emoji('skip_emoji', $config) || '  ';
    $ignore_emoji  = _set_emoji('ignore_emoji', $config) || '  ';
} else {
    $success_emoji = '';
    $failure_emoji = '';
    $skip_emoji    = '';
    $ignore_emoji  = '';
}

# Reading the checksum data
my ($checksums, $checksums_file) = _read_checksums($nochecksums_flag, $checksums_src);

if ($about_flag) {
    say "$PROGRAM_NAME version $VERSION";
    say '';
    say 'With environment';
    say "\$CLICOLOR = $ENV{CLICOLOR}"             if exists $ENV{CLICOLOR};
    say "\$CLICOLOR_FORCE = $ENV{CLICOLOR_FORCE}" if exists $ENV{CLICOLOR_FORCE};
    say '';
    if (not $noconfig_flag) {
        say "Using configuration located at: $config_file";
        say 'Configured with:';
        say '- debug: '.$config->[0]->{debug} if $config->[0]->{debug};
        say '- verbose: '.$config->[0]->{verbose} if $config->[0]->{verbose};
        say '- color: '.$config->[0]->{color} if $config->[0]->{color};
        if ($config->[0]->{yakignores}) {
            say '- yakignores: ';
            foreach my $yakignore (@{$config->[0]->{yakignores}}) {
                say "  - $yakignore";
            }
        }
        say '';
    }
    say "Using data source located at: $checksums_file";
    say '';
    say 'Invoked with:';
    say '--debug'                    if $debug_flag;
    say '--nodebug'                  if $nodebug_flag;
    say '--verbose'                  if $verbosity_flag;
    say '--noconfig'                 if $noconfig_flag;
    say "--config $config_src"       if $config_src;
    say '--silent'                   if $silent_flag;
    say '--nochecksums'              if $nochecksums_flag;
    say "--checksums $checksums_src" if $checksums_src;
    say '--nocolor'                  if $nocolor_flag;
    say '--color'                    if $color_flag;
    say '--noemoji'                  if $noemoji_flag;
    say '--emoji'                    if $emoji_flag;
    say '--about'                    if $about_flag;

    exit $rv;
}

if ($help_flag) {
    _print_help();
    exit $rv;
}

if ($verbose) {
    say "$PROGRAM_NAME : $VERSION";
}

my $yakignores = _set_yakignores($config);

# Our global matcher
my $matcher = build_gitignore_matcher($yakignores);

# Our stack of matchers to match assist our directory descend (preprocess) and ascend (postprocess)
my $directory_stack = new Data::Stack();

if ($matcher) {
    my ($current_directory) = getcwd() =~ m{/([\w-]+)$}; # we need the last part of the complete path
    $directory_stack->push({ directory => $current_directory, matcher => $matcher });
}

find({ wanted => \&_process, preprocess => \&_preprocess, postprocess => \&_postprocess }, qw(.));

exit $rv;

sub _process {
    $matcher->($_)
    && _print_ignore($color, $ignore_emoji, $File::Find::name)
    && ($File::Find::prune = TRUE)
    || _subprocess($_);
}

sub _subprocess {
    my $file = shift;

    #print STDERR Dumper $checksums;

    if (-f $file and any { $file eq $_ } keys %{$checksums} ) {

        my $checksum;
        my $assertion = $checksums->{$file};

        if ($assertion =~ m/file/i) {
            my ($filename) = $assertion =~ s{file:\/\/(.*)}{$1};
            $checksum = sha256_file_hex("$HOME/.config/yak/files/$assertion");
        } elsif ($assertion eq $JSON::true) {
            _print_success($color, $success_emoji, $File::Find::name) unless $silent_flag;
        } elsif ($assertion eq $JSON::false) {
            _print_failure($color, $failure_emoji, $File::Find::name) unless $silent_flag;
            $rv = FAILURE;

        } else {
            $checksum = $assertion;
        }

        if ($checksum) {
            my $file_checksum = sha256_file_hex($file);

            if ($file_checksum eq $checksum) {
                _print_success($color, $success_emoji, $File::Find::name) unless $silent_flag;
            } else {
                _print_failure($color, $failure_emoji, $File::Find::name) unless $silent_flag;
                $rv = FAILURE;
            }
        }

    } elsif (-f $file and $verbose) {
        _print_skip($color, $skip_emoji, $File::Find::name) unless $silent_flag;
    }

    return $rv;
}

sub _preprocess {

    if (-e '.yakignore' and -f _ and -r _) {
        my @lines = read_lines('.yakignore');
        my $local_matcher = build_gitignore_matcher([@lines]);
        $directory_stack->push({ directory => $File::Find::dir, matcher => $local_matcher });
        $matcher = $local_matcher;

        if ($debug_flag) {
            say STDERR "_preprocess: Located .yakignore in $File::Find::dir";
        }
    }

    # REF: http://jonasbn.github.io/til/cpan/file-find.html
    return @_;
}

sub _postprocess {

    if (-e '.yakignore' and -f _ and -r _) {

        my $element = $directory_stack->peek();

        if ($element->{directory} eq $File::Find::dir) {
            $directory_stack->pop;
            $element = $directory_stack->pop;
            $matcher = $element->{matcher};
        }

        if ($debug_flag) {
            say STDERR "_postprocess: Located .yakignore in $File::Find::dir";
        }
    }
}

sub _read_config {
    my ($noconfig_flag, $config_file) = @_;

    my $config;

    if (not $noconfig_flag) {
        if ($config_file and (not -e $config_file or not -f _ or not -r _)) {
            die "Specified configuration file: $config_file, does not exist, is not a file or cannot be read";
        }
        $config_file = $config_file?$config_file:$default_config_file;

        if ($config_file and not -e $config_file or not -f _ or not -r _) {
            die "Specified configuration file: $config_file, does not exist, is not a file or cannot be read";
        }

        $config = YAML::Tiny->read($config_file);
    }

    return ($config, $config_file);
}

sub _read_checksums {
    my ($nochecksums_flag, $checksums_src) = @_;

    my $checksums_file = '';

    if ($nochecksums_flag) {
        my $cwd = getcwd();
        $checksums_file = "$cwd/.yaksums.json";
    } else {

        if ($checksums_src) {
            $checksums_file = $checksums_src;
        } else {
            $checksums_file = $default_checksums_src;
        }
    }

    my $checksums;

    if ($checksums_file and (not -e $checksums_file or not -f _ or not -r _)) {
        die 'No checksums file available, please specify either a checksum file in the configuration directory or in the designated directory';
    } else {
        open (my $checksums_fh, '<', $checksums_file) or die "Unable to read checksum file: $checksums_file - $!";
        my $checksum_json = join '', <$checksums_fh>;
        close $checksums_fh;

        $checksums = from_json($checksum_json);
    }

    return ($checksums, $checksums_file);
}

sub _set_emoji {
    my ($key, $config) = @_;

    return $config->[0]->{$key} || '';
}

sub _print_success {
    my ($color, $emoji, $filename, $silent_flag) = @_;

    unless ($silent_flag) {
        if ($color) {
            say GREEN, $emoji . $filename . RESET;
        } else {
            say $emoji . $filename;
        }
    }
}

sub _print_failure {
    my ($color, $emoji, $filename, $silent_flag) = @_;

    unless ($silent_flag) {
        if ($color) {
            say RED, $emoji . $filename . RESET;
        } else {
            say $emoji . $filename;
        }
    }
}

sub _print_skip {
    my ($color, $emoji, $filename, $silent_flag) = @_;

    unless ($silent_flag) {
        if ($color) {
            say FAINT, $emoji . "$filename skipped", RESET;
        } else {
            say $emoji, "$filename skipped";
        }
    }
}

sub _print_ignore {
    my ($color, $emoji, $filename, $silent_flag) = @_;

    unless ($silent_flag) {
        if ($color) {
            say FAINT, $emoji . "$filename ignored", RESET;
        } else {
            say $emoji, "$filename ignored";
        }
    }
}

sub _print_help {
    say "$PROGRAM_NAME version $VERSION";
    say '';
    say "$PROGRAM_NAME [options]";
    say '';
    say 'Options';
    say '';
    say '--debug: debug output';
    say '--nodebug: disabling debug output, if configured';
    say '--verbose: more verbose output';
    say '--noconfig: ignore \$HOME/.config/.yak/config.yml';
    say '--config <file>: specify alternative to \$HOME/.config/.yak/config.yml';
    say '--silent: suppress all output and rely on return value';
    say '--nochecksums: ignore \$HOME/.config/.yak/checksums.json and use local .yaksums';
    say '--checksums <file>: specify alternative to \$HOME/.config/.yak/checksums.json';
    say '--nocolor: disable colorized output';
    say '--color: enable colorized output';
    say '--noemoji: disable emoji output';
    say '--emoji: enable emoji output';
    say '--about: emit configuration and invocation description';    

    return FAILURE;
}

sub _enable_verbose {
    my ($verbosity_flag, $silent_flag, $config) = @_;

    if ($silent_flag) {
        return FALSE;
    }

    return $verbosity_flag || _is_config_true($config, 'verbose') || FALSE;
}

sub _enable_debug {
    my ($debug_flag, $nodebug_flag, $config) = @_;

    if ($nodebug_flag) {
        return FALSE;
    }

    return $debug_flag || _is_config_true($config, 'debug') || FALSE;
}

sub _enable_color {
    my ($color_flag, $nocolor_flag, $config) = @_;

    if (exists($ENV{CLICOLOR_FORCE}) && $ENV{CLICOLOR_FORCE} == FALSE) {
        return FALSE;
    } elsif (exists($ENV{CLICOLOR_FORCE}) && $ENV{CLICOLOR_FORCE} != FALSE) {
        return TRUE;
    }

    if ($nocolor_flag) {
        return FALSE;
    }

    if ($color_flag) {
        return TRUE;
    }

    if (exists($ENV{CLICOLOR}) && $ENV{CLICOLOR} == FALSE) {
        return FALSE;
    } elsif (exists($ENV{CLICOLOR}) && $ENV{CLICOLOR} != TRUE) {
        return TRUE;
    }

    return _is_config_false($config, 'color')?FALSE:TRUE;
}

sub _enable_emoji {
    my ($emoji_flag, $noemoji_flag, $config) = @_;

    if ($noemoji_flag) {
        return FALSE;
    }

    if ($emoji_flag) {
        return TRUE;
    }

    return _is_config_false($config, 'emoji')?FALSE:TRUE;
}

sub _set_yakignores {
    my $config = shift;

    my $yakignores = [];

    if ($config and $config->[0]->{yakignores}) {
        $yakignores = $config->[0]->{yakignores};
    }

    return $yakignores;
}

sub _is_config_false {
    my ($config, $key) = @_;

    if ($config and $config->[0]->{$key}) {
        return $config->[0]->{$key} eq 'false'?TRUE:FALSE;
    } else {
        return FALSE;
    }
}

sub _is_config_true {
    my ($config, $key) = @_;

    if ($config and $config->[0]->{$key}) {
        return $config->[0]->{$key} eq 'true'?TRUE:FALSE;
    } else {
        return FALSE;
    }
}
