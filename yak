#!/usr/bin/env perl

use strict;
use warnings;
use v5.10; # say

use JSON; # from_json
use YAML::Tiny;
use Crypt::Digest::SHA256 qw(sha256_file_hex); # Provided by CryptX
use Env qw($HOME);
use Data::Dumper;
use File::Find;
use List::MoreUtils qw(any);
use Term::ANSIColor qw(:constants);
use English; # $PROGRAM_NAME
use Getopt::Long; # GetOptions
use Cwd; # getcwd

use constant FALSE   => 0;
use constant TRUE    => 1;
use constant SUCCESS => 0;
use constant FAILURE => 1;

our $VERSION = '1.0.0';

my $default_checksums_src  = "$HOME/.config/yak/checksums.json";
my $default_config_file    = "$HOME/.config/yak/config.yml";

my $debug_flag       = FALSE;
my $nodebug_flag     = FALSE;
my $verbosity_flag   = FALSE;
my $silent_flag      = FALSE;
my $noconfig_flag    = FALSE;
my $nochecksums_flag = FALSE;
my $about_flag       = FALSE;
my $help_flag        = FALSE;
my $nocolor_flag     = FALSE;
my $color_flag       = FALSE;
my $noemoji_flag     = FALSE;
my $emoji_flag       = FALSE;
my $rv               = SUCCESS;
my $checksums_src    = '';
my $config_file      = '';

GetOptions ('debug'       => \$debug_flag,
            'nodebug'     => \$nodebug_flag,
            'verbose'     => \$verbosity_flag,
            'noconfig'    => \$noconfig_flag,
            'config=s'    => \$config_file,
            'silent'      => \$silent_flag,
            'nochecksums' => \$nochecksums_flag,
            'checksums=s' => \$checksums_src,
            'nocolor'     => \$nocolor_flag,
            'color'       => \$color_flag,
            'noemoji'     => \$noemoji_flag,
            'emoji'       => \$emoji_flag,
            'about'       => \$about_flag,
            'help'        => \$help_flag,
) or die "Error in command line arguments\n";

# Reading the config
my $config;
if ($noconfig_flag) {
    #$config;
} else {
    if ($config_file) {
        $config = YAML::Tiny->read($config_file);
    } else {
        $config = YAML::Tiny->read($default_config_file);
    }
}

my $verbose = _set_verbose($verbosity_flag, $silent_flag, $config);
my $debug = _set_debug($debug_flag, $nodebug_flag, $config);
my $color = _set_color($color_flag, $nocolor_flag, $config);
my $emoji = _set_emoji($emoji_flag, $noemoji_flag, $config);

# Reading the checksum data
my $checksums_file = '';
if ($nochecksums_flag) {
    my $cwd = getcwd();
    $checksums_file = "$cwd/.yaksums.json";
} else {

    if ($checksums_src) {
        $checksums_file = $checksums_src;
    } else {
        $checksums_file = $default_checksums_src;
    }
}

open (my $checksums_fh, '<', $checksums_file) or die "Unable to read checksum file: $checksums_file - $!";
my $checksum_json = join '', <$checksums_fh>;
close $checksums_fh;

my $checksums = from_json($checksum_json);

if ($about_flag) {
    say "$PROGRAM_NAME version $VERSION";
    say '';
    if (not $noconfig_flag) {
        say "Using configuration located at: $config_file" ;
        say 'Configured with:';
        say '- debug: '.$config->[0]->{debug} if $config->[0]->{debug};
        say '- verbose: '.$config->[0]->{verbose} if $config->[0]->{verbose};
        say '- color: '.$config->[0]->{color} if $config->[0]->{color};
        say '';
    }
    say "Using data source located at: $checksums_file";
    say '';
    say 'Invoked with:';
    say '--debug'                    if $debug_flag;
    say '--nodebug'                  if $nodebug_flag;
    say '--verbose'                  if $verbosity_flag;
    say '--noconfig'                 if $noconfig_flag;
    say '--config $config_file'      if $config_file;
    say '--silent'                   if $silent_flag;
    say '--nochecksums'              if $nochecksums_flag;
    say '--checksums $checksums_src' if $checksums_src;
    say '--nocolor'                  if $nocolor_flag;
    say '--color'                    if $color_flag;
    say '--noemoji'                  if $noemoji_flag;
    say '--emoji'                    if $emoji_flag;
    say '--about'                    if $about_flag;

    exit $rv;
}

if ($help_flag) {
    say "$PROGRAM_NAME version $VERSION";
    say '';
    say "$PROGRAM_NAME [options]";
    say '';
    say 'Options';
    say '';
    say '--debug: debug output';
    say '--nodebug: disabling debug output, if configured';
    say '--verbose: more verbose output';
    say '--noconfig: ignore \$HOME/.config/.yak/config.yml';
    say '--config <file>: specify alternative to \$HOME/.config/.yak/config.yml';
    say '--silent: suppress all output and rely on return value';
    say '--nochecksums: ignore \$HOME/.config/.yak/checksums.json and use local .yaksums';
    say '--checksums <file>: specify alternative to \$HOME/.config/.yak/checksums.json';
    say '--nocolor: disable colorized output';
    say '--color: enable colorized output';
    say '--noemoji: disable emoji output';
    say '--emoji: enable emoji output';
    say '--about: emit configuration and invocation description';

    exit $rv;
}

if (defined $ARGV[0]) {
    my $file_checksum = sha256_file_hex($ARGV[0]);
} else {
    find(\&_wanted, qw(.));
}

exit $rv;

sub _wanted {
    my $file = $_;

    if ($debug) {
        say STDERR "Examining: $File::Find::dir";
        say STDERR "Examining: $_";
        say STDERR "Examining: $File::Find::name";
    }

    if (-f $file and any { $file eq $_ } keys %{$checksums} ) {

        my $checksum;
        my $assertion = $checksums->{$file};

        if ($assertion =~ m/file/i) {
            my ($filename) = $assertion =~ s{file:\/\/(.*)}{$1};
            $checksum = sha256_file_hex("$HOME/.config/yak/files/$assertion");
        } else {
            $checksum = $assertion;
        }

        my $file_checksum = sha256_file_hex($file);

        if ($file_checksum eq $checksum) {
            _print_success($color, $emoji, $File::Find::name) unless $silent_flag;
        } else {
            _print_failure($color, $emoji, $File::Find::name)  unless $silent_flag;
            $rv = FAILURE;
        }
    } elsif (-f $file and $verbose) {
        _print_skip($color, $emoji, $File::Find::name) unless $silent_flag;
    }
}

sub _print_success {
    my ($color, $emoji, $filename, $silent_flag) = @_;

    my $success_emoji = '👍🏻';
    if (not $emoji) {
        $success_emoji = '';
    }

    unless ($silent_flag) {
        if ($color) {
            say GREEN, $success_emoji . $filename . RESET;
        } else {
            say $success_emoji . $filename;
        }
    }
}

sub _print_failure {
    my ($color, $emoji, $filename, $silent_flag) = @_;

    my $failure_emoji = '❗️';
    if (not $emoji) {
        $failure_emoji = '';
    }

    unless ($silent_flag) {
        if ($color) {
            say  RED, $failure_emoji . $filename . RESET;
        } else {
            say $failure_emoji . $filename;
        }
    }
}

sub _print_skip {
    my ($color, $emoji, $filename, $silent_flag) = @_;

    my $skip_emoji = '  ';
    if (not $emoji) {
        $skip_emoji = '';
    }

    unless ($silent_flag) {
        if ($color) {
            say FAINT, $skip_emoji . "$filename skipped", RESET;
        } else {
            say $skip_emoji, "$filename skipped";
        }
    }
}

sub _set_verbose {
    my ($verbosity_flag, $silent_flag, $config) = @_;

    if ($silent_flag) {
        return FALSE;
    }

    return $verbosity_flag || _is_verbosity_config_true($config) || FALSE;
}

sub _set_debug {
    my ($debug_flag, $nodebug_flag, $config) = @_;

    if ($nodebug_flag) {
        return FALSE;
    }

    return $debug_flag || _is_debug_config_true($config) || FALSE;
}

sub _set_color {
    my ($color_flag, $nocolor_flag, $config) = @_;

    if ($nocolor_flag) {
        return FALSE;
    }

    if ($color_flag) {
        return TRUE;
    }

    return _is_color_config_false($config)?FALSE:TRUE;
}

sub _set_emoji {
    my ($emoji_flag, $noemoji_flag, $config) = @_;

    if ($noemoji_flag) {
        return FALSE;
    }

    if ($emoji_flag) {
        return TRUE;
    }

    return _is_emoji_config_false($config)?FALSE:TRUE;
}

sub _is_emoji_config_false {
    my $config = shift;

    if ($config and $config->[0]->{emoji}) {
        return $config->[0]->{emoji} eq 'false'?TRUE:FALSE;
    } else {
        return FALSE;
    }
}

sub _is_color_config_false {
    my $config = shift;

    if ($config and $config->[0]->{color}) {
        return $config->[0]->{color} eq 'false'?TRUE:FALSE;
    } else {
        return FALSE;
    }
}

sub _is_debug_config_true {
    my $config = shift;

    if ($config and $config->[0]->{debug}) {
        return $config->[0]->{debug} eq 'true'?TRUE:FALSE;
    } else {
        return FALSE;
    }
}

sub _is_verbosity_config_true {
    my $config = shift;

    if ($config and $config->[0]->{verbose}) {
        return $config->[0]->{verbose} eq 'true'?TRUE:FALSE;
    } else {
        return FALSE;
    }
}

__END__

=pod

=encoding UTF-8

=begin markdown

[![Build Status](https://travis-ci.org/jonasbn/yak.svg?branch=master)](https://travis-ci.org/jonasbn/yak)

:warning: WARNING! :warning:

This this project and it's components are WIP and *alpha* software, everything is far from working and even farther from finished

---

=end markdown

=head1 yak

yak - script to help with yak shaving for example GitHub projects

=head1 DESCRIPTION

The C<yak> I<shaver> can scan a directory for files, which can be classified as yaks in need of shaving. Meaning files which are maintained else where are often copy-pasted.

The file names can be configured in a central configuration file, like this:

F<$HOME/.config/yak/checksums.json>

    {
        "CONTRIBUTING.md": "15701b6b27e1d49ca6636f2695cfc49b6622c7152f74b14becc53850811db54f"
    }

If a file is encountered, which matches the name, the checksum of the encountered file is calculated and is compared to the checksum listed in the central file.

=over

=item * If they match, everything is okay

=item * If they differ, the difference has to be addressed

=back

The recommendation is to have the checksum in the central file, reflect the authoritative revision and hence you can overwrite the file in the directory you where inspecting.

Alternatively to specifying a checksum, you can specify a file URL:

    {
        "MANIFEST.SKIP": "file://MANIFEST.SKIP"
    }

The file pointed to has to be available in: F<$HOME/.config/yak/files>

Then C<yak> can calculate the checksum dynamically, based on the reference file and can based on invocation copy the reference file to the location of the evaluated file in the case where the two differ.

=head2 CHECKSUM DATA FILE EXAMPLE

This JSON file should be created as C<$HOME/.config/yak/checksums.json>.

    {
        "CODE_OF_CONDUCT.md": "da9eed24b35eed80ce28e07b02725dbb356cfa56500a1552a1410ab5c73af82c",
        "CONTRIBUTING.md": "file://CONTRIBUTING.md",
        "PULL_REQUEST_TEMPLATE.md": "91dabee84afd46f93894d1a266a773f3d46c2c0b1ae4813f0c7dba34df1dc260",
        "MANIFEST.SKIP": "file://MANIFEST.SKIP"
    }

=head1 INVOCATION

C<yak> takes the following command line arguments:

=over

=item * C<--verbose>, enables more verbose output, can be configured see L</CONFIGURATION>

=item * C<--silent>, disables output and you have to rely on the return value see L</RETURN_VALUES> below.

=item * C<--debug>, enables debug output. can be configured see L</CONFIGURATION>

=item * C<--nodebug>, disables debug output even if confgured or provided as C<--debug>, see above

=item * C<--config file>, reads alternative configuration file instead of default, see L</CONFIGURATION>

=item * C<--noconfig>, disables reading of the configuration file, (see L</CONFIGURATION>) and you have to rely on the command line arguments

=item * C<--nochecksums>, disables reading of the global checksums file, see L</DATA_SOURCE>

=item * C<--checksums file>, reads alternative checksums file instead of default, see L</DATA_SOURCE>

=item * C<--color>, enables colorized output, enabled by default or can be configured, see L</CONFIGURATION>

=item * C<--nocolor>, disables colorized output, even if confgured or provided as C<--color>, see above

=item * C<--emoji>, enables emojis in output, enabled by default or can be configured, see L</CONFIGURATION>

=item * C<--noemoji>, disables emojis in output, even if confgured or provided as C<--emoji>, see above

=item * C<--about>, emits output on configuration and invocation and terminates with success

=item * C<--help>, emits help message listing all available options

=back

Command line arguments override the configuration.

=head2 RETURN VALUES

=over

=item * C<0>, success, everything is okay

=item * C<1>, failure, a located filed did not match the designated checksum

=back

Note that C<--about> return as success with out processing any data apart from reading configuration and parsing command line arguments.

=head1 CONFIGURATION

F<$HOME/.config/yak/config.yml>

C<yak> can be configured using the following paramters:

=over

=item * C<verbose>, enabling (C<true>) or disabling (C<false>) more verbose output

=item * C<debug>, enabling (C<true>) or disabling (C<false>) debug output

=item * C<color>, enabling (C<true>) or disabling (C<false>) colorized output

=item * C<emoji>, enabling (C<true>) or disabling (C<false>) colorized output

=back

Configuration can be overridden by command line arguments, see L</INVOCATION>.

=head2 EXAMPLE CONFIGURATION

This YAML file should be created as C<$HOME/.config/yak/config.yml>.

    verbose: false
    debug: false

=head1 DATA SOURCE

There are 3 ways to provide checksum data to C<yak>.

=over

=item * The default using: C<$HOME/.config/yak/checksums.json>, which can then be edited to match your needs

=item * Using a project or repository specific: C<.yaksums.json> located in the root of your project or repository directory

=item * Using an JSON file adhering to formatting described in this chapter, which can be located elsewhere on your file system

=back

The default data source is described in the L</DESCRIPTION>. As a an alternative a per project file can be specified in the designated repository/directory.

The file should be named: C<.yaksums.json>

The contents follow the same format as the C<$HOME/.config/yak/checksums.json>.

This JSON file should look as follows:

    {
        "<filename>": "<sha256 checksum for the file specifed by the filename>"
    }

An example:

    {
        "CODE_OF_CONDUCT.md": "da9eed24b35eed80ce28e07b02725dbb356cfa56500a1552a1410ab5c73af82c",
        "CONTRIBUTING.md": "file://CONTRIBUTING.md",
        "PULL_REQUEST_TEMPLATE.md": "91dabee84afd46f93894d1a266a773f3d46c2c0b1ae4813f0c7dba34df1dc260",
        "MANIFEST.SKIP": "file://MANIFEST.SKIP"
    }

=head1 USING DOCKER

An experimental Docker implementation has been included with the repository.

It can be built using the following statement:

    $ docker build -t jonasbn/yak .

And then run as follows:

    $ docker run --rm -it -v $PWD:/tmp jonasbn/yak

It will consume all the command line arguments (see L</INVOCATION>).

The Docker image has the following command line arguments embedded:

=over

=item * C<--noconfig>

=item * C<--nochecksums>

=back

Since the ability to read files outside the Docker container is limited to mounted directories.

The mount point is expected to be a directory containing the files to be checked against the checksum data structure. Please see the L</LIMITATIONS> for details.

=head1 LIMITATIONS

=over

=item * Running under Docker is limited to using only checksums specified in a local <.yaksums.json> and configuration has to be specified using command line arguments not a file

=item * The use of a local: C<.yaksums.json> is limited to checksums and cannot calculate based on files, since files are located in an unmounted directory

=back

=head1 ISSUE REPORTING

If you experience any issues with C<yak> report these via GitHub. Please read  L<the issue reporting template|https://github.com/jonasbn/yak/blob/master/.github/ISSUE_TEMPLATE.md>.

=head1 DEVELOPMENT

If you want to contribute to C<yak> please read the L<Contribution guidelines|https://github.com/jonasbn/yak/blob/master/CONTRIBUTING.md>
and follow L<the pull request guidelines|https://github.com/jonasbn/yak/blob/master/.github/PULL_TEMPLATE.md>.

=head1 MOTIVATION

Much of what I do is yak shaving. For you who are not familiar with the term:

    "[MIT AI Lab, after 2000: orig. probably from a Ren & Stimpy episode.]
    Any seemingly pointless activity which is actually necessary to solve
    a problem which solves a problem which, several levels of recursion
    later, solves the real problem you're working on."

REF: L<The Jargon File|http://www.catb.org/~esr/jargon/html/Y/yak-shaving.html>

Used commonly for repetive and boring work, required to reach a certain goal.

=head1 AUTHOR

=over

=item * jonasbn, L<website|https://jonasbn.github.io/>

=back

=head1 COPYRIGHT

C<yak> is (C) by Jonas Brømsø, (jonasbn) 2018-2020

Image used on the C<yak> L<website|https://jonasbn.github.io/yak/> is under copyright by L<Shane Aldendorff|https://unsplash.com/photos/3b3O75X0Jzg>

=head1 LICENSE

C<yak> is released under the MIT License

=cut
